<section class="our-services p-relative py-5 my-5">
    <span class="custom-circle custom-circle-2 bg-color-quaternary appear-animation" data-appear-animation="zoomIn"
        data-appear-animation-delay="100"></span>
    <div class="container">
        <div class="row justify-content-center">
            <h4 class="text-color-light custom-text-10 font-weight-bold text-center custom-title-with-icon-center custom-title-with-icon custom-title-with-icon-primary pb-5 mb-4 appear-animation"
                data-appear-animation="fadeInUpShorter" data-appear-animation-delay="200">Prediksi Sekarang:</h4>
        </div>

        <div class="row">
            <div class="col">
                <div class="tabs tabs-bottom tabs-center tabs-simple">
                    <ul class="nav nav-tabs" role="tablist">
                        <li class="nav-item active" role="presentation">
                            <a class="nav-link active" href="#tabsNavigationSimpleIcons1" data-bs-toggle="tab"
                                aria-selected="true" role="tab">
                                <span class="featured-boxes featured-boxes-style-6 p-0 m-0">
                                    <span class="featured-box featured-box-primary featured-box-effect-6 p-0 m-0">
                                        <span class="box-content p-0 m-0">
                                            <i class="icon-featured fas fa-user"></i>
                                        </span>
                                    </span>
                                </span>
                                <p class="mb-0 pb-0">Konfigurasi Area Parkir</p>
                            </a>
                        </li>
                        <li class="nav-item" role="presentation">
                            <a class="nav-link" href="#tabsNavigationSimpleIcons2" data-bs-toggle="tab"
                                aria-selected="false" role="tab" tabindex="-1">
                                <span class="featured-boxes featured-boxes-style-6 p-0 m-0">
                                    <span class="featured-box featured-box-primary featured-box-effect-6 p-0 m-0">
                                        <span class="box-content p-0 m-0">
                                            <i class="icon-featured fas fa-file"></i>
                                        </span>
                                    </span>
                                </span>
                                <p class="mb-0 pb-0">Deteksi Okupansi</p>
                            </a>
                        </li>
                    </ul>
                    <div class="tab-content">
                        <div class="tab-pane active show" id="tabsNavigationSimpleIcons1" role="tabpanel">
                            {% include 'components/setting-parkir.html' %}
                        </div>

                        <div class="tab-pane" id="tabsNavigationSimpleIcons2" role="tabpanel">
                            <div class="row">
                                <div class="col-md-4">
                                    <div id="messages"></div>
                                    <!-- File upload form -->
                                    <form id="upload-form" enctype="multipart/form-data">
                                        <h4>Upload Image or Video</h4>
                                        <div class="form-group">
                                            <input type="file" class="form-control form-control-sm text-light" id="file" name="file" accept="image/*, video/*" required>
                                        </div>
                                        <button type="submit" class="btn btn-primary col-12">Upload</button>
                                    </form>
                                </div>
                                <div class="col-md-8">
                                    <div id="loading" style="display: none;">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                    </div>
                                    <!-- Image prediction display -->
                                    <div id="image-result" style="display:none;">
                                        <div class="row">
                                            <div class="col-md-6">
                                                <h5>Original Image</h5>
                                                <img id="original-image" class="img-fluid">
                                            </div>
                                            <div class="col-md-6">
                                                <h5>Processed Image</h5>
                                                <img id="processed-image" class="img-fluid">
                                            </div>
                                        </div>
                                    </div>                            
                                    
                                    <!-- Video stream display -->
                                    <div id="video-result" style="display:none;">
                                        <img id="video-frame" class="img-fluid rounded">
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</section>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        const uploadForm = document.getElementById('upload-form');
        const loadingIndicator = document.getElementById('loading');
        const messages = document.getElementById('messages');

        uploadForm.addEventListener('submit', async (event) => {
            event.preventDefault();
        
            const formData = new FormData(uploadForm);
        
            // Show the loading indicator
            showLoadingIndicator();
        
            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'Accept': 'application/json',
                    },
                });
        
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Unknown error');
                }

                const result = await response.json();
                displayMessage(result.message, 'info');
        
                if (result.image_path && result.prediction_path) {
                    displayImages(result.image_path, result.prediction_path);
                } else if (result.video_path) {
                    displayVideo(result.video_path);
                }
            } catch (error) {
                displayMessage(error.message, 'danger');
            } finally {
                hideLoadingIndicator();
            }
        });

        function displayMessage(message, type) {
            messages.innerHTML = `
                <div class="alert alert-${type} alert-dismissible" role="alert">
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    ${message}
                </div>
            `;
        }
    
        function displayImages(imagePath, predictionPath) {
            document.getElementById('original-image').src = `/static/${imagePath}?${Date.now()}`;
            document.getElementById('processed-image').src = `/static/${predictionPath}?${Date.now()}`;

            // hapus src video agar tidak mengkonsumsi vga
            document.getElementById('video-frame').src = ``;
            document.getElementById('image-result').style.display = 'block';
            document.getElementById('video-result').style.display = 'none';
        }
    
        function displayVideo(videoPath) {
            document.getElementById('video-frame').src = `/video_feed?video_path=${videoPath}`;
            document.getElementById('video-result').style.display = 'block';
            document.getElementById('image-result').style.display = 'none';
        }

        function showLoadingIndicator() {
        loadingIndicator.style.display = 'block';
        messages.innerHTML = '';
        }
    
        function hideLoadingIndicator() {
        loadingIndicator.style.display = 'none';
        }
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const boundingBoxes = [];
        let currentBox = [];
        let imgWidth, imgHeight;
        const img = new Image();
        let isDragging = false;
        let dragPointIndex = null;
        let dragBoxIndex = null;
        let zoomLevel = 1;
        const zoomStep = 0.1;
    
        document.getElementById('upload-image').addEventListener('change', handleImageUpload);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseOut);
        document.getElementById('remove-last-box').addEventListener('click', removeLastBoundingBox);
        document.getElementById('save-boxes').addEventListener('click', saveBoundingBoxes);
        document.getElementById('download-boxes').addEventListener('click', downloadBoundingBoxes);
        document.getElementById('zoom-in').addEventListener('click', zoomIn);
        document.getElementById('zoom-out').addEventListener('click', zoomOut);
    
        function handleImageUpload(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
    
            reader.onload = (e) => {
                img.src = e.target.result;
                img.onload = () => {
                    imgWidth = img.width;
                    imgHeight = img.height;
                    const maxWidth = canvasContainer.clientWidth;
                    const scaleFactor = maxWidth / imgWidth;
    
                    canvas.width = maxWidth;
                    canvas.height = imgHeight * scaleFactor;
    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    redrawCanvas();
                }
            }
    
            reader.readAsDataURL(file);
        }
    
        function handleMouseDown(event) {
            const { x, y } = getMousePosition(event);
    
            for (let i = 0; i < boundingBoxes.length; i++) {
                for (let j = 0; j < boundingBoxes[i].length; j++) {
                    const point = boundingBoxes[i][j];
                    if (isNearPoint(x, y, point[0], point[1])) {
                        startDragging(i, j);
                        return;
                    }
                }
            }
    
            if (!isDragging) {
                addPointToCurrentBox(x, y);
            }
        }
    
        function handleMouseMove(event) {
            if (isDragging) {
                const { x, y } = getMousePosition(event);
                updateDraggedPoint(x, y);
                redrawCanvas();
            }
        }
    
        function handleMouseUp() {
            stopDragging();
        }
    
        function handleMouseOut() {
            stopDragging();
        }
    
        function startDragging(boxIndex, pointIndex) {
            isDragging = true;
            dragBoxIndex = boxIndex;
            dragPointIndex = pointIndex;
        }
    
        function stopDragging() {
            isDragging = false;
            dragBoxIndex = null;
            dragPointIndex = null;
        }
    
        function addPointToCurrentBox(x, y) {
            currentBox.push([x, y]);
            drawPoint(x, y);
    
            if (currentBox.length > 1) {
                drawLine(currentBox[currentBox.length - 2], currentBox[currentBox.length - 1]);
            }
    
            if (currentBox.length === 4) {
                boundingBoxes.push(currentBox);
                drawBoundingBox(currentBox);
                currentBox = [];
            }
        }
    
        function updateDraggedPoint(x, y) {
            boundingBoxes[dragBoxIndex][dragPointIndex] = [x, y];
        }
    
        function drawPoint(x, y) {
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(x * zoomLevel, y * zoomLevel, 3, 0, 2 * Math.PI);
            ctx.fill();
        }
    
        function drawLine(start, end) {
            ctx.strokeStyle = "green";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(start[0] * zoomLevel, start[1] * zoomLevel);
            ctx.lineTo(end[0] * zoomLevel, end[1] * zoomLevel);
            ctx.stroke();
        }
    
        function drawBoundingBox(box) {
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(box[0][0] * zoomLevel, box[0][1] * zoomLevel);
            ctx.lineTo(box[1][0] * zoomLevel, box[1][1] * zoomLevel);
            ctx.lineTo(box[2][0] * zoomLevel, box[2][1] * zoomLevel);
            ctx.lineTo(box[3][0] * zoomLevel, box[3][1] * zoomLevel);
            ctx.closePath();
            ctx.stroke();
            box.forEach(point => drawPoint(point[0], point[1]));
        }
    
        function isNearPoint(x, y, px, py) {
            const distance = 5;
            return Math.abs(x - px) < distance && Math.abs(y - py) < distance;
        }
    
        function removeLastBoundingBox() {
            if (boundingBoxes.length > 0) {
                boundingBoxes.pop();
                redrawCanvas();
            } else {
                alert("No bounding boxes to remove");
            }
        }
    
        function saveBoundingBoxes() {
            const rescaledBoundingBoxes = rescaleBoundingBoxes();
    
            fetch('/save_boxes', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(rescaledBoundingBoxes)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Bounding boxes saved successfully!');
                } else {
                    alert('Error saving bounding boxes.');
                }
            });
        }
    
        function downloadBoundingBoxes() {
            const rescaledBoundingBoxes = rescaleBoundingBoxes();
            const blob = new Blob([JSON.stringify(rescaledBoundingBoxes, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
    
            a.href = url;
            a.download = 'bounding_boxes.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    
        function rescaleBoundingBoxes() {
            const widthScalingFactor = imgWidth / (canvas.width / zoomLevel);
            const heightScalingFactor = imgHeight / (canvas.height / zoomLevel);
    
            return boundingBoxes.map(box => ({
                points: box.map(([x, y]) => [
                    Math.round(x * widthScalingFactor),
                    Math.round(y * heightScalingFactor)
                ])
            }));
        }
    
        function zoomIn() {
            zoomLevel += zoomStep;
            redrawCanvas();
        }
    
        function zoomOut() {
            if (zoomLevel > zoomStep) {
                zoomLevel -= zoomStep;
                redrawCanvas();
            }
        }
    
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const scaledWidth = imgWidth * zoomLevel;
            const scaledHeight = imgHeight * zoomLevel;
            canvas.width = scaledWidth;
            canvas.height = scaledHeight;
            canvasContainer.style.width = `${scaledWidth}px`;
            canvasContainer.style.height = `${scaledHeight}px`;
            ctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
            boundingBoxes.forEach(drawBoundingBox);
        }
    
        function getMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (event.clientX - rect.left) / zoomLevel,
                y: (event.clientY - rect.top) / zoomLevel
            };
        }
    });
</script>
